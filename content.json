{"meta":{"title":"willpower","subtitle":"有规划的生活学习，努力，坚持","description":"","author":"Tian","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"响应式布局","slug":"hello-world","date":"2020-02-05T10:51:14.000Z","updated":"2020-07-08T14:03:59.976Z","comments":true,"path":"2020/02/05/hello-world/","link":"","permalink":"http://yoursite.com/2020/02/05/hello-world/","excerpt":"","text":"一.手机移动端响应式布局1.remREM是CSS3新增的单位，并且移动端的支持度很高，Android2.x+,ios5+都支持。rem单位都是相对于根元素html的font-size来决定大小的,根元素的font-size相当于提供了一个基准，当页面的size发生变化时，只需要改变font-size的值，那么以rem为固定单位的元素的大小也会发生响应的变化。 因此，如果通过rem来实现响应式的布局，只需要根据视图容器的大小，动态的改变font-size即可（而em是相对于父元素的）。 响应式的布局思想 一般不要给元素设置具体的宽度，但是对于一些小图标可以设定具体宽度值 高度值可以设置固定值，设计稿有多大，我们就严格有多大 所有设置的固定值都用rem做单位（首先在HTML总设置一个基准值：px和rem的对应比例，然后在效果图上获取px值，布局的时候转化为rem值) js获取真实屏幕的宽度，让其除以设计稿的宽度，算出比例，把之前的基准值按照比例进行重新的设定，这样项目就可以在移动端自适应了 rem布局的缺点：在响应式布局中，必须通过js来动态控制根元素font-size的大小，也就是说css样式和js代码有一定的耦合性，且必须将改变font-size的代码放在css样式之前 123456789/*上述代码中将视图容器分为10份，font-size用十分之一的宽度来表示，最后在header标签中执行这段代码，就可以动态定义font-size的大小，从而1rem在不同的视觉容器中表示不同的大小，用rem固定单位可以实现不同容器内布局的自适应。*/function refreshRem() &#123; var docEl = doc.documentElement; var width = docEl.getBoundingClientRect().width; var rem = width / 10; docEl.style.fontSize = rem + 'px'; flexible.rem = win.rem = rem;&#125;win.addEventListener('resize', refreshRem); REM布局也是目前多屏幕适配的最佳方式。默认情况下我们html标签的font-size为16px,我们利用媒体查询，设置在不同设备下的字体大小。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* pc width &gt; 1100px */html&#123; font-size: 100%;&#125;body &#123; background-color: yellow; font-size: 1.5rem;&#125;/* ipad pro */@media screen and (max-width: 1024px) &#123; body &#123; background-color: #FF00FF; font-size: 1.4rem; &#125;&#125;/* ipad */@media screen and (max-width: 768px) &#123; body &#123; background-color: green; font-size: 1.3rem; &#125;&#125;/* iphone6 7 8 plus */@media screen and (max-width: 414px) &#123; body &#123; background-color: blue; font-size: 1.25rem; &#125;&#125;/* iphoneX */@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 3) &#123; body &#123; background-color: #0FF000; font-size: 1.125rem; &#125;&#125;/* iphone6 7 8 */@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 2) &#123; body &#123; background-color: #0FF000; font-size: 1rem; &#125;&#125;/* iphone5 */@media screen and (max-width: 320px) &#123; body &#123; background-color: #0FF000; font-size: 0.75rem; &#125;&#125; 2.视口单位css3中引入了一个新的单位vw/vh，与视图窗口有关，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。","categories":[],"tags":[]},{"title":"算法总结（js）","slug":"text","date":"2020-01-06T08:51:14.000Z","updated":"2020-07-07T15:12:24.566Z","comments":true,"path":"2020/01/06/text/","link":"","permalink":"http://yoursite.com/2020/01/06/text/","excerpt":"","text":"冒泡排序手写代码123456789101112131415161718let arr = [3, 4, 1, 2];let max = arr.length - 1;for(let i = 0; i &lt; max; i++)&#123; // 声明一个变量，作为标志位 // 如果某次循环完后，没有任何两数进行交换，就将标志位设置为 true，表示排序完成 let flag = true; for(let j = 0; j &lt; max - i; j++)&#123; if(arr[j] &gt; arr[j + 1])&#123; // 利用ES6数组的解构赋值交换数据 [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; flag = false; &#125; &#125; if(flag)&#123; break; &#125;&#125;console.log(arr); 选择排序手写代码123456789101112131415let arr = [3, 4, 1, 2];let len = arr.length;// 这里之所以是len-1，是因为到最后两个元素，交换位置，整个数组就已经排好序了。for(let i = 0; i &lt; len - 1; i++)&#123; let min = arr[i]; // j = i+1是把与自己比较的情况给省略掉 for(let j = i+1; j &lt; len; j++)&#123; if(arr[j] &lt; min)&#123; // 利用ES6数组的解构赋值交换数据 [arr[j], min] = [min, arr[j]]; &#125; &#125; arr[i] = min;&#125;console.log(arr);","categories":[],"tags":[]}],"categories":[],"tags":[]}