{"meta":{"title":"willpower","subtitle":"有规划的生活学习，努力，坚持","description":"","author":"Tian","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"前端性能优化","slug":"optimization","date":"2020-04-18T12:03:15.000Z","updated":"2020-07-09T13:26:56.337Z","comments":true,"path":"2020/04/18/optimization/","link":"","permalink":"http://yoursite.com/2020/04/18/optimization/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"响应式布局","slug":"hello-world","date":"2020-02-05T10:51:14.000Z","updated":"2020-07-09T03:43:15.200Z","comments":true,"path":"2020/02/05/hello-world/","link":"","permalink":"http://yoursite.com/2020/02/05/hello-world/","excerpt":"","text":"注：以下方法不仅仅只适用与移动端或pc端，只是在该端更有适用性 一.手机移动端响应式布局1.remREM是CSS3新增的单位，并且移动端的支持度很高，Android2.x+,ios5+都支持。rem单位都是相对于根元素html的font-size来决定大小的,根元素的font-size相当于提供了一个基准，当页面的size发生变化时，只需要改变font-size的值，那么以rem为固定单位的元素的大小也会发生响应的变化。 因此，如果通过rem来实现响应式的布局，只需要根据视图容器的大小，动态的改变font-size即可（而em是相对于父元素的）。 rem响应式的布局思想 一般不要给元素设置具体的宽度，但是对于一些小图标可以设定具体宽度值 高度值可以设置固定值，设计稿有多大，我们就严格有多大 所有设置的固定值都用rem做单位（首先在HTML总设置一个基准值：px和rem的对应比例，然后在效果图上获取px值，布局的时候转化为rem值) js获取真实屏幕的宽度，让其除以设计稿的宽度，算出比例，把之前的基准值按照比例进行重新的设定，这样项目就可以在移动端自适应了 rem布局的缺点：在响应式布局中，必须通过js来动态控制根元素font-size的大小，也就是说css样式和js代码有一定的耦合性，且必须将改变font-size的代码放在css样式之前 123456789/*上述代码中将视图容器分为10份，font-size用十分之一的宽度来表示，最后在header标签中执行这段代码，就可以动态定义font-size的大小，从而1rem在不同的视觉容器中表示不同的大小，用rem固定单位可以实现不同容器内布局的自适应。*/function refreshRem() &#123; var docEl = doc.documentElement; var width = docEl.getBoundingClientRect().width; var rem = width / 10; docEl.style.fontSize = rem + 'px'; flexible.rem = win.rem = rem;&#125;win.addEventListener('resize', refreshRem); REM布局也是目前多屏幕适配的最佳方式。默认情况下我们html标签的font-size为16px,我们利用媒体查询，设置在不同设备下的字体大小。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* pc width &gt; 1100px */html&#123; font-size: 100%;&#125;body &#123; background-color: yellow; font-size: 1.5rem;&#125;/* ipad pro */@media screen and (max-width: 1024px) &#123; body &#123; background-color: #FF00FF; font-size: 1.4rem; &#125;&#125;/* ipad */@media screen and (max-width: 768px) &#123; body &#123; background-color: green; font-size: 1.3rem; &#125;&#125;/* iphone6 7 8 plus */@media screen and (max-width: 414px) &#123; body &#123; background-color: blue; font-size: 1.25rem; &#125;&#125;/* iphoneX */@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 3) &#123; body &#123; background-color: #0FF000; font-size: 1.125rem; &#125;&#125;/* iphone6 7 8 */@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 2) &#123; body &#123; background-color: #0FF000; font-size: 1rem; &#125;&#125;/* iphone5 */@media screen and (max-width: 320px) &#123; body &#123; background-color: #0FF000; font-size: 0.75rem; &#125;&#125; 2.视口单位css3中引入了一个新的单位vw/vh，与视图窗口有关，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。 用视口单位度量，视口宽度为100vw，高度为100vh。例如，在桌面端浏览器视口尺寸为650px，那么 1vw = 650 * 1% = 6.5px（这是理论推算的出，如果浏览器不支持0.5px，那么实际渲染结果可能是7px）。 使用视口单位来实现响应式有两种做法： （1）仅使用vw作为css单位 对于设计稿的尺寸转换为为单位，我们使用Sass函数编译12345//iPhone 6尺寸作为设计稿基准$vm_base: 375; @function vw($px) &#123; @return ($px / 375) * 100vw;&#125; 无论是文本还是布局宽度、间距等都使用vw作为单位 1234567891011121314151617181920212223242526.nav &#123; background-color: #fff; list &#123; display: flex; padding: vw(15) vw(10) vw(10); // 内间距 item &#123; flex: 1; text-align: center; font-size: vw(10); // 字体大小 logo &#123; display: block; margin: 0 auto; width: vw(40); // 宽度 height: vw(40); // 高度 img &#123; display: block; margin: 0 auto; max-width: 100%; &#125; &#125; name &#123; margin-top: vw(2); &#125; &#125; &#125;&#125; （2）搭配vw和rem虽然采用vw适配后的页面效果很好，但是它是利用视口单位实现的布局，依赖视口大小而自动缩放，无论视口过大还是过小，它也随着时候过大或者过小，失去了最大最小宽度的限制，此时我们可以结合rem来实现布局 二、PC端响应式布局1.百分比布局通过百分比单位，可以使得浏览器中组件的宽和高随着浏览器的高度的变化而变化，从而实现响应式的效果。Bootstrap里面的栅格系统就是利用百分比来定义元素的宽高，CSS3支持最大最小高，可以将百分比和max(min)一起结合使用来定义元素在不同设备下的宽高。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/* pc width &gt; 1100px */html, body &#123; margin: 0;padding: 0;width: 100%;height: 100%;&#125;aside &#123; width: 10%; height: 100%; background-color: red; float: left;&#125;main &#123; height: 100%; background-color: blue; overflow: hidden;&#125;/* ipad pro */@media screen and (max-width: 1024px) &#123; aside &#123; width: 8%; background-color: yellow; &#125;&#125;/* ipad */@media screen and (max-width: 768px) &#123; aside &#123; float: none; width: 100%; height: 10%; background-color: green; &#125; main &#123; height: calc(100vh - 10%); background-color: red; &#125;&#125;/* iphone6 7 8 plus */@media screen and (max-width: 414px) &#123; aside &#123; float: none; width: 100%; height: 5%; background-color: yellow; &#125; main &#123; height: calc(100vh - 5%); background-color: red; &#125;&#125;/* iphoneX */@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 3) &#123; aside &#123; float: none; width: 100%; height: 10%; background-color: blue; &#125; main &#123; height: calc(100vh - 10%); background-color: red; &#125;&#125;/* iphone6 7 8 */@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 2) &#123; aside &#123; float: none; width: 100%; height: 3%; background-color: black; &#125; main &#123; height: calc(100vh - 3%); background-color: red; &#125;&#125;/* iphone5 */@media screen and (max-width: 320px) &#123; aside &#123; float: none; width: 100%; height: 7%; background-color: green; &#125; main &#123; height: calc(100vh - 7%); background-color: red; &#125;&#125; 三、移动端，pc端，pad端多端口适配1.媒体查询CSS3媒体查询可以让我们针对不同的媒体类型定义不同的样式，当重置浏览器窗口大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。 如何选择屏幕大小分割点如何确定媒体查询的分割点也是一个开发中会遇到的问题。 如果我们选择600px,900px,1200px,1800px作为分割点，可以适配到常见的14个机型。 当然这只是其中的一种分割方案，我们还可以这样划分：480px,800px,1400px,1400px。 上边两种分割方案不一定满足项目中的实际需求，我们可以先用跨度大的分割点进行分割，如果出现不适配的情况可以再根据实际情况增加新的分割点。 移动优先 or PC优先不管是移动优先还是PC优先，都是依据当随着屏幕宽度增大或减小的时候，后面的样式会覆盖前面的样式。因此，移动端优先首先使用的是min-width，PC端优先使用的max-width。 移动优先12345678910111213141516171819202122232425262728293031323334353637383940/* iphone6 7 8 */body &#123; background-color: yellow;&#125;/* iphone 5 */@media screen and (max-width: 320px) &#123; body &#123; background-color: red; &#125;&#125;/* iphoneX */@media screen and (min-width: 375px) and (-webkit-device-pixel-ratio: 3) &#123; body &#123; background-color: #0FF000; &#125;&#125;/* iphone6 7 8 plus */@media screen and (min-width: 414px) &#123; body &#123; background-color: blue; &#125;&#125;/* ipad */@media screen and (min-width: 768px) &#123; body &#123; background-color: green; &#125;&#125;/* ipad pro */@media screen and (min-width: 1024px) &#123; body &#123; background-color: #FF00FF; &#125;&#125;/* pc */@media screen and (min-width: 1100px) &#123; body &#123; background-color: black; &#125;&#125; pc优先12345678910111213141516171819202122232425262728293031323334353637383940/* pc width &gt; 1024px */ body &#123; background-color: yellow; &#125;/* ipad pro */@media screen and (max-width: 1024px) &#123; body &#123; background-color: #FF00FF; &#125;&#125;/* ipad */@media screen and (max-width: 768px) &#123; body &#123; background-color: green; &#125;&#125;/* iphone6 7 8 plus */@media screen and (max-width: 414px) &#123; body &#123; background-color: blue; &#125;&#125;/* iphoneX */@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 3) &#123; body &#123; background-color: #0FF000; &#125;&#125;/* iphone6 7 8 */@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 2) &#123; body &#123; background-color: #0FF000; &#125;&#125;/* iphone5 */@media screen and (max-width: 320px) &#123; body &#123; background-color: #0FF000; &#125;&#125; 四、其它布局方法1.flex布局谈到flex布局，我不知道有多少人跟我一样，在本能的想到justify-content:center与align-items:center两条属性之后，除此之外的其它属性居然显得格外陌生。 可以说包括我在内的大部分人，都是在被flex垂直水平居中方式所惊艳后才对其有所了解，以至于在日常开发中对于flex的使用，也确实更偏向于元素对齐方式的使用。 而flex布局则是一种新的布局方案，通过为修改父div的display属性，让父元素成为一个flex容器，从而可以自由的操作容器中子元素(项目)的排列方式。 例如我们让多个div横向排列，传统做法是使用浮动，但浮空后因为脱离文档流的缘故，父元素会失去高度，这又涉及了清除浮动等一系列的问题。 而flex布局相对简单很多，修改父元素display:flex，你会发现div自动就排列成了一行，而且没有浮动之后的副作用，从回流角度考虑，flex的性能更优于float；随着浏览器不断兼容以及旧版本的淘汰，flex布局注定会成为更为流行的布局方案。 优点容易上手，根据flex规则很容易达到某个布局效果。 缺点兼容性较差具体兼容性可参考 https://caniuse.com/#feat=flexbox 由上述网站兼容性可以知道pc端,尤其是ie浏览器对flex布局并不友好。而移动端ios7,android4.4以上对flex布局几乎没有太大影响了，在手机迭代更新如此快的今天，flex布局在移动端是一个不错的选择。 2.网格布局，栅格布局 Grid网格布局，兼容性较差 Columns栅格系统，往往需要依赖某个UI库，如Bootstrap 总结响应式布局的实现可以通过媒体查询+px,媒体查询+百分比，媒体查询+rem+js,vm/vh,vm/vh +rem这几种方式来实现。但每一种方式都是有缺点的，媒体查询需要选取主流设备宽度尺寸作为断点针对性写额外的样式进行适配，但这样做会比较麻烦，只能在选取的几个主流设备尺寸下呈现完美适配，另外用户体验也不友好，布局在响应断点范围内的分辨率下维持不变，而在响应断点切换的瞬间，布局带来断层式的切换变化，如同卡带的唱机般“咔咔咔”地一下又一下。通过百分比来适配首先是计算麻烦，第二各个属性中如果使用百分比，其相对的元素的属性并不是唯一的，这样就造成我们使用百分比单位容易使布局问题变得复杂。通过采用rem单位的动态计算的弹性布局，则是需要在头部内嵌一段脚本来进行监听分辨率的变化来动态改变根元素字体大小，使得CSS与JS 耦合了在一起。通过利用纯css视口单位实现适配的页面，是既能解决响应式断层问题，又能解决脚本依赖的问题的，但是兼容性还没有完全能结构接受。","categories":[],"tags":[]},{"title":"算法总结（js）","slug":"text","date":"2020-01-06T08:51:14.000Z","updated":"2020-07-07T15:12:24.566Z","comments":true,"path":"2020/01/06/text/","link":"","permalink":"http://yoursite.com/2020/01/06/text/","excerpt":"","text":"冒泡排序手写代码123456789101112131415161718let arr = [3, 4, 1, 2];let max = arr.length - 1;for(let i = 0; i &lt; max; i++)&#123; // 声明一个变量，作为标志位 // 如果某次循环完后，没有任何两数进行交换，就将标志位设置为 true，表示排序完成 let flag = true; for(let j = 0; j &lt; max - i; j++)&#123; if(arr[j] &gt; arr[j + 1])&#123; // 利用ES6数组的解构赋值交换数据 [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; flag = false; &#125; &#125; if(flag)&#123; break; &#125;&#125;console.log(arr); 选择排序手写代码123456789101112131415let arr = [3, 4, 1, 2];let len = arr.length;// 这里之所以是len-1，是因为到最后两个元素，交换位置，整个数组就已经排好序了。for(let i = 0; i &lt; len - 1; i++)&#123; let min = arr[i]; // j = i+1是把与自己比较的情况给省略掉 for(let j = i+1; j &lt; len; j++)&#123; if(arr[j] &lt; min)&#123; // 利用ES6数组的解构赋值交换数据 [arr[j], min] = [min, arr[j]]; &#125; &#125; arr[i] = min;&#125;console.log(arr);","categories":[],"tags":[]}],"categories":[],"tags":[]}