{"meta":{"title":"willpower","subtitle":"有规划的生活学习，努力，坚持","description":"","author":"Tian","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"前端性能优化","slug":"optimization","date":"2020-04-18T12:03:15.000Z","updated":"2020-07-15T14:54:38.800Z","comments":true,"path":"2020/04/18/optimization/","link":"","permalink":"http://yoursite.com/2020/04/18/optimization/","excerpt":"","text":"","categories":[{"name":"其它","slug":"其它","permalink":"http://yoursite.com/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"其它","slug":"其它","permalink":"http://yoursite.com/tags/%E5%85%B6%E5%AE%83/"}]},{"title":"Vue中8种组件通信方式","slug":"Vuecommunication","date":"2020-04-06T03:16:12.000Z","updated":"2020-07-20T07:43:10.930Z","comments":true,"path":"2020/04/06/Vuecommunication/","link":"","permalink":"http://yoursite.com/2020/04/06/Vuecommunication/","excerpt":"","text":"一、props / $emit父组件通过props的方式向子组件传递数据，而通过$emit 子组件可以向父组件通信。 1. 父组件向子组件传值下面通过一个例子说明父组件如何向子组件传递数据：在子组件article.vue中如何获取父组件section.vue中的数据articles:[‘手机’, ‘平板’,’电脑’] 123456789101112131415161718&#x2F;&#x2F; section父组件 &lt;template&gt; &lt;div class&#x3D;&quot;section&quot;&gt; &lt;com-article :articles&#x3D;&quot;articleList&quot;&gt;&lt;&#x2F;com-article&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import comArticle from &#39;.&#x2F;test&#x2F;article.vue&#39; export default &#123; name: &#39;HelloWorld&#39;, components: &#123; comArticle &#125;, data() &#123; return &#123; articleList: [&#39;手机&#39;, &#39;电脑&#39;, &#39;平板&#39;] &#125; &#125; &#125; &lt;&#x2F;script&gt; 1234567891011&#x2F;&#x2F; 子组件 article.vue &lt;template&gt; &lt;div&gt; &lt;span v-for&#x3D;&quot;item in articles&quot; :key&#x3D;&quot;item&quot;&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;span&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; props: [&#39;articles&#39;] &#125; &lt;&#x2F;script&gt; 2. 子组件向父组件传值$emit绑定一个自定义事件, 当这个语句被执行时, 就会将参数arg传递给父组件,父组件通过v-on监听并接收参数。在上个例子的基础上, 点击页面渲染出来的ariticle的item, 父组件中显示该item在数组中的索引值 12345678910111213141516171819202122232425&#x2F;&#x2F; 父组件中 &lt;template&gt; &lt;div class&#x3D;&quot;section&quot;&gt; &lt;com-article :articles&#x3D;&quot;articleList&quot; @onEmitIndex&#x3D;&quot;onEmitIndex&quot;&gt;&lt;&#x2F;com-article&gt; &lt;p&gt;&#123;&#123;currentIndex&#125;&#125;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import comArticle from &#39;.&#x2F;test&#x2F;article.vue&#39; export default &#123; name: &#39;HelloWorld&#39;, components: &#123; comArticle &#125;, data() &#123; return &#123; currentIndex: -1, articleList: [&#39;手机&#39;, &#39;电脑&#39;, &#39;平板&#39;] &#125; &#125;, methods: &#123; onEmitIndex(idx) &#123; this.currentIndex &#x3D; idx &#125; &#125; &#125; &lt;&#x2F;script&gt; 123456789101112131415&lt;template&gt; &lt;div&gt; &lt;div v-for&#x3D;&quot;(item, index) in articles&quot; :key&#x3D;&quot;index&quot; @click&#x3D;&quot;emitIndex(index)&quot;&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; props: [&#39;articles&#39;], methods: &#123; emitIndex(index) &#123; this.$emit(&#39;onEmitIndex&#39;, index) &#125; &#125; &#125; &lt;&#x2F;script&gt; 二、 $children / $parent1234567891011121314151617181920212223242526&#x2F;&#x2F; 父组件中 &lt;template&gt; &lt;div class&#x3D;&quot;hello_world&quot;&gt; &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;div&gt; &lt;com-a&gt;&lt;&#x2F;com-a&gt; &lt;button @click&#x3D;&quot;changeA&quot;&gt;点击改变子组件值&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import ComA from &#39;.&#x2F;test&#x2F;comA.vue&#39; export default &#123; name: &#39;HelloWorld&#39;, components: &#123; ComA &#125;, data() &#123; return &#123; msg: &#39;Welcome&#39; &#125; &#125;, methods: &#123; changeA() &#123; &#x2F;&#x2F; 获取到子组件A this.$children[0].messageA &#x3D; &#39;this is new value&#39; &#125; &#125; &#125; &lt;&#x2F;script&gt; 123456789101112131415161718192021&#x2F;&#x2F; 子组件中 &lt;template&gt; &lt;div class&#x3D;&quot;com_a&quot;&gt; &lt;span&gt;&#123;&#123;messageA&#125;&#125;&lt;&#x2F;span&gt; &lt;p&gt;获取父组件的值为: &#123;&#123;parentVal&#125;&#125;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; data() &#123; return &#123; messageA: &#39;this is old&#39; &#125; &#125;, computed:&#123; parentVal()&#123; return this.$parent.msg; &#125; &#125; &#125; &lt;&#x2F;script&gt; 注意：如在#app上拿$parent得到的是new Vue()的实例，在这实例上再拿$parent得到的是undefined，而在最底层的子组件拿$children是个空数组。也要注意得到$parent和$children的值不一样，$children 的值是数组，而$parent是个对象。 上面两种方式用于父子组件之间的通信， 而使用props进行父子组件通信更加普遍; 二者皆不能用于非父子组件之间的通信。 三、provide/ injectprovide/ inject 是vue2.2.0新增的api, 简单来说就是父组件中通过provide来提供变量, 然后再子组件中通过inject来注入变量。 注意: 这里不论子组件嵌套有多深, 只要调用了inject 那么就可以注入provide中的数据，而不局限于只能从当前父组件的props属性中回去数据 举例验证 接下来就用一个例子来验证上面的描述: 假设有三个组件: A.vue、B.vue、C.vue 其中 C是B的子组件，B是A的子组件 123456789101112131415161718&#x2F;&#x2F; A.vue &lt;template&gt; &lt;div&gt; &lt;comB&gt;&lt;&#x2F;comB&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import comB from &#39;..&#x2F;components&#x2F;test&#x2F;comB.vue&#39; export default &#123; name: &quot;A&quot;, provide: &#123; for: &quot;demo&quot; &#125;, components:&#123; comB &#125; &#125; &lt;&#x2F;script&gt; 12345678910111213141516171819202122&#x2F;&#x2F; B.vue &lt;template&gt; &lt;div&gt; &#123;&#123;demo&#125;&#125; &lt;comC&gt;&lt;&#x2F;comC&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import comC from &#39;..&#x2F;components&#x2F;test&#x2F;comC.vue&#39; export default &#123; name: &quot;B&quot;, inject: [&#39;for&#39;], data() &#123; return &#123; demo: this.for &#125; &#125;, components: &#123; comC &#125; &#125; &lt;&#x2F;script&gt; 1234567891011121314151617&#x2F;&#x2F; C.vue &lt;template&gt; &lt;div&gt; &#123;&#123;demo&#125;&#125; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; name: &quot;C&quot;, inject: [&#39;for&#39;], data() &#123; return &#123; demo: this.for &#125; &#125; &#125; &lt;&#x2F;script&gt; 四、ref / refsref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例，可以通过实例直接调用组件的方法或访问数据， 我们看一个ref 来访问组件的例子: 12345678910111213// 子组件 A.vue export default &#123; data () &#123; return &#123; name: 'Vue.js' &#125; &#125;, methods: &#123; sayHello () &#123; console.log('hello') &#125; &#125; &#125; 12345678910111213&#x2F;&#x2F; 父组件 app.vue &lt;template&gt; &lt;component-a ref&#x3D;&quot;comA&quot;&gt;&lt;&#x2F;component-a&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; mounted () &#123; const comA &#x3D; this.$refs.comA; console.log(comA.name); &#x2F;&#x2F; Vue.js comA.sayHello(); &#x2F;&#x2F; hello &#125; &#125; &lt;&#x2F;script&gt; 五、eventBuseventBus 又称为事件总线，在vue中可以使用它来作为沟通桥梁的概念, 就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件， 所以组件都可以通知其他组件。 eventBus也有不方便之处, 当项目较大,就容易造成难以维护的灾难 在Vue的项目中怎么使用eventBus来实现组件之间的数据通信呢?具体通过下面几个步骤 1. 初始化首先需要创建一个事件总线并将其导出, 以便其他模块可以使用或者监听它. 123// event-bus.js import Vue from 'vue' export const EventBus = new Vue() 2. 发送事件假设你有两个组件: additionNum 和 showNum, 这两个组件可以是兄弟组件也可以是父子组件；这里我们以兄弟组件为例: 12345678910111213&lt;template&gt; &lt;div&gt; &lt;show-num-com&gt;&lt;&#x2F;show-num-com&gt; &lt;addition-num-com&gt;&lt;&#x2F;addition-num-com&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import showNumCom from &#39;.&#x2F;showNum.vue&#39; import additionNumCom from &#39;.&#x2F;additionNum.vue&#39; export default &#123; components: &#123; showNumCom, additionNumCom &#125; &#125; &lt;&#x2F;script&gt; 123456789101112131415161718192021222324&#x2F;&#x2F; addtionNum.vue 中发送事件 &lt;template&gt; &lt;div&gt; &lt;button @click&#x3D;&quot;additionHandle&quot;&gt;+加法器&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import &#123;EventBus&#125; from &#39;.&#x2F;event-bus.js&#39; console.log(EventBus) export default &#123; data()&#123; return&#123; num:1 &#125; &#125;, methods:&#123; additionHandle()&#123; EventBus.$emit(&#39;addition&#39;, &#123; num:this.num++ &#125;) &#125; &#125; &#125; &lt;&#x2F;script&gt; 3. 接收事件12345678910111213141516171819&#x2F;&#x2F; showNum.vue 中接收事件 &lt;template&gt; &lt;div&gt;计算和: &#123;&#123;count&#125;&#125;&lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import &#123; EventBus &#125; from &#39;.&#x2F;event-bus.js&#39; export default &#123; data() &#123; return &#123; count: 0 &#125; &#125;, mounted() &#123; EventBus.$on(&#39;addition&#39;, param &#x3D;&gt; &#123; thisthis.count &#x3D; this.count + param.num; &#125;) &#125; &#125; &lt;&#x2F;script&gt; 这样就实现了在组件addtionNum.vue中点击相加按钮, 在showNum.vue中利用传递来的 num 展示求和的结果. 4. 移除事件监听者如果想移除事件的监听, 可以像下面这样操作: 12import &#123; eventBus &#125; from 'event-bus.js' EventBus.$off('addition', &#123;&#125;) 六、Vuex1. Vuex介绍Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化. Vuex 解决了多个视图依赖于同一状态和来自不同视图的行为需要变更同一状态的问题，将开发者的精力聚焦于数据的更新而不是数据在组件之间的传递上 2.Vuex各个模块 state：用于数据的存储，是store中的唯一数据源 getters：如vue中的计算属性一样，基于state数据的二次包装，常用于数据的筛选和多个数据的相关性计算 mutations：类似函数，改变state数据的唯一途径，且不能用于处理异步事件 actions：类似于mutation，用于提交mutation来改变状态，而不直接变更状态，可以包含任意异步操作 modules：类似于命名空间，用于项目中将各个模块的状态分开定义和操作，便于维护 七、 localStorage / sessionStorage这种通信比较简单,缺点是数据和状态比较混乱,不太容易维护。 通过window.localStorage.getItem(key) 获取数据 通过window.localStorage.setItem(key,value) 存储数据 注意用JSON.parse() / JSON.stringify() 做数据格式转换 localStorage / sessionStorage可以结合vuex, 实现数据的持久保存,同时使用vuex解决数据和状态混乱问题. 八、 $attrs与 $listeners现在我们来讨论一种情况， 我们一开始给出的组件关系图中A组件与D组件是隔代关系， 那它们之前进行通信有哪些方式呢？ 1.使用props绑定来进行一级一级的信息传递, 如果D组件中状态改变需要传递数据给A, 使用事件系统一级级往上传递 2.使用eventBus,这种情况下还是比较适合使用, 但是碰到多人合作开发时, 代码维护性较低, 可读性也低 3.使用Vuex来进行数据管理, 但是如果仅仅是传递数据, 而不做中间处理,使用Vuex处理感觉有点大材小用了.在vue2.4中，为了解决该需求，引入了$attrs 和$listeners ， 新增了inheritAttrs 选项。 在版本2.4以前，默认情况下,父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)，将会“回退”且作为普通的HTML特性应用在子组件的根元素上。接下来看一个跨级通信的例子: 123456789101112131415161718192021222324252627&#x2F;&#x2F; app.vue &#x2F;&#x2F; index.vue &lt;template&gt; &lt;div&gt; &lt;child-com1 :name&#x3D;&quot;name&quot; :age&#x3D;&quot;age&quot; :gender&#x3D;&quot;gender&quot; :height&#x3D;&quot;height&quot; title&#x3D;&quot;程序员成长指北&quot; &gt;&lt;&#x2F;child-com1&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; const childCom1 &#x3D; () &#x3D;&gt; import(&quot;.&#x2F;childCom1.vue&quot;); export default &#123; components: &#123; childCom1 &#125;, data() &#123; return &#123; name: &quot;zhang&quot;, age: &quot;18&quot;, gender: &quot;女&quot;, height: &quot;158&quot; &#125;; &#125; &#125;; &lt;&#x2F;script&gt; 123456789101112131415161718192021222324&#x2F;&#x2F; childCom1.vue &lt;template class&#x3D;&quot;border&quot;&gt; &lt;div&gt; &lt;p&gt;name: &#123;&#123; name&#125;&#125;&lt;&#x2F;p&gt; &lt;p&gt;childCom1的$attrs: &#123;&#123; $attrs &#125;&#125;&lt;&#x2F;p&gt; &lt;child-com2 v-bind&#x3D;&quot;$attrs&quot;&gt;&lt;&#x2F;child-com2&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; const childCom2 &#x3D; () &#x3D;&gt; import(&quot;.&#x2F;childCom2.vue&quot;); export default &#123; components: &#123; childCom2 &#125;, inheritAttrs: false, &#x2F;&#x2F; 可以关闭自动挂载到组件根元素上的没有在props声明的属性 props: &#123; name: String &#x2F;&#x2F; name作为props属性绑定 &#125;, created() &#123; console.log(this.$attrs); &#x2F;&#x2F; &#123; &quot;age&quot;: &quot;18&quot;, &quot;gender&quot;: &quot;女&quot;, &quot;height&quot;: &quot;158&quot;, &quot;title&quot;: &quot;程序员成长指北&quot; &#125; &#125; &#125;; &lt;&#x2F;script&gt; 12345678910111213141516171819&#x2F;&#x2F; childCom2.vue &lt;template&gt; &lt;div class&#x3D;&quot;border&quot;&gt; &lt;p&gt;age: &#123;&#123; age&#125;&#125;&lt;&#x2F;p&gt; &lt;p&gt;childCom2: &#123;&#123; $attrs &#125;&#125;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; inheritAttrs: false, props: &#123; age: String &#125;, created() &#123; console.log(this.$attrs); &#x2F;&#x2F; &#123; &quot;gender&quot;: &quot;女&quot;, &quot;height&quot;: &quot;158&quot;, &quot;title&quot;: &quot;程序员成长指北&quot; &#125; &#125; &#125;; &lt;&#x2F;script&gt; 总结常见使用场景可以分为三类: 父子组件通信: props; $parent / $children; provide / inject ; ref ; $attrs / $listeners 兄弟组件通信: eventBus ; vuex 跨级通信: eventBus；Vuex；provide / inject 、$attrs / $listeners","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"响应式布局","slug":"hello-world","date":"2020-02-05T10:51:14.000Z","updated":"2020-07-15T14:52:30.106Z","comments":true,"path":"2020/02/05/hello-world/","link":"","permalink":"http://yoursite.com/2020/02/05/hello-world/","excerpt":"","text":"注：以下方法不仅仅只适用与移动端或pc端，只是在该端更有适用性 一.手机移动端响应式布局1.remREM是CSS3新增的单位，并且移动端的支持度很高，Android2.x+,ios5+都支持。rem单位都是相对于根元素html的font-size来决定大小的,根元素的font-size相当于提供了一个基准，当页面的size发生变化时，只需要改变font-size的值，那么以rem为固定单位的元素的大小也会发生响应的变化。 因此，如果通过rem来实现响应式的布局，只需要根据视图容器的大小，动态的改变font-size即可（而em是相对于父元素的）。 rem响应式的布局思想 一般不要给元素设置具体的宽度，但是对于一些小图标可以设定具体宽度值 高度值可以设置固定值，设计稿有多大，我们就严格有多大 所有设置的固定值都用rem做单位（首先在HTML总设置一个基准值：px和rem的对应比例，然后在效果图上获取px值，布局的时候转化为rem值) js获取真实屏幕的宽度，让其除以设计稿的宽度，算出比例，把之前的基准值按照比例进行重新的设定，这样项目就可以在移动端自适应了 rem布局的缺点：在响应式布局中，必须通过js来动态控制根元素font-size的大小，也就是说css样式和js代码有一定的耦合性，且必须将改变font-size的代码放在css样式之前 123456789/*上述代码中将视图容器分为10份，font-size用十分之一的宽度来表示，最后在header标签中执行这段代码，就可以动态定义font-size的大小，从而1rem在不同的视觉容器中表示不同的大小，用rem固定单位可以实现不同容器内布局的自适应。*/function refreshRem() &#123; var docEl = doc.documentElement; var width = docEl.getBoundingClientRect().width; var rem = width / 10; docEl.style.fontSize = rem + 'px'; flexible.rem = win.rem = rem;&#125;win.addEventListener('resize', refreshRem); REM布局也是目前多屏幕适配的最佳方式。默认情况下我们html标签的font-size为16px,我们利用媒体查询，设置在不同设备下的字体大小。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* pc width &gt; 1100px */html&#123; font-size: 100%;&#125;body &#123; background-color: yellow; font-size: 1.5rem;&#125;/* ipad pro */@media screen and (max-width: 1024px) &#123; body &#123; background-color: #FF00FF; font-size: 1.4rem; &#125;&#125;/* ipad */@media screen and (max-width: 768px) &#123; body &#123; background-color: green; font-size: 1.3rem; &#125;&#125;/* iphone6 7 8 plus */@media screen and (max-width: 414px) &#123; body &#123; background-color: blue; font-size: 1.25rem; &#125;&#125;/* iphoneX */@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 3) &#123; body &#123; background-color: #0FF000; font-size: 1.125rem; &#125;&#125;/* iphone6 7 8 */@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 2) &#123; body &#123; background-color: #0FF000; font-size: 1rem; &#125;&#125;/* iphone5 */@media screen and (max-width: 320px) &#123; body &#123; background-color: #0FF000; font-size: 0.75rem; &#125;&#125; 2.视口单位css3中引入了一个新的单位vw/vh，与视图窗口有关，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。 用视口单位度量，视口宽度为100vw，高度为100vh。例如，在桌面端浏览器视口尺寸为650px，那么 1vw = 650 * 1% = 6.5px（这是理论推算的出，如果浏览器不支持0.5px，那么实际渲染结果可能是7px）。 使用视口单位来实现响应式有两种做法： （1）仅使用vw作为css单位 对于设计稿的尺寸转换为为单位，我们使用Sass函数编译12345//iPhone 6尺寸作为设计稿基准$vm_base: 375; @function vw($px) &#123; @return ($px / 375) * 100vw;&#125; 无论是文本还是布局宽度、间距等都使用vw作为单位 1234567891011121314151617181920212223242526.nav &#123; background-color: #fff; list &#123; display: flex; padding: vw(15) vw(10) vw(10); // 内间距 item &#123; flex: 1; text-align: center; font-size: vw(10); // 字体大小 logo &#123; display: block; margin: 0 auto; width: vw(40); // 宽度 height: vw(40); // 高度 img &#123; display: block; margin: 0 auto; max-width: 100%; &#125; &#125; name &#123; margin-top: vw(2); &#125; &#125; &#125;&#125; （2）搭配vw和rem虽然采用vw适配后的页面效果很好，但是它是利用视口单位实现的布局，依赖视口大小而自动缩放，无论视口过大还是过小，它也随着时候过大或者过小，失去了最大最小宽度的限制，此时我们可以结合rem来实现布局 二、PC端响应式布局1.百分比布局通过百分比单位，可以使得浏览器中组件的宽和高随着浏览器的高度的变化而变化，从而实现响应式的效果。Bootstrap里面的栅格系统就是利用百分比来定义元素的宽高，CSS3支持最大最小高，可以将百分比和max(min)一起结合使用来定义元素在不同设备下的宽高。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/* pc width &gt; 1100px */html, body &#123; margin: 0;padding: 0;width: 100%;height: 100%;&#125;aside &#123; width: 10%; height: 100%; background-color: red; float: left;&#125;main &#123; height: 100%; background-color: blue; overflow: hidden;&#125;/* ipad pro */@media screen and (max-width: 1024px) &#123; aside &#123; width: 8%; background-color: yellow; &#125;&#125;/* ipad */@media screen and (max-width: 768px) &#123; aside &#123; float: none; width: 100%; height: 10%; background-color: green; &#125; main &#123; height: calc(100vh - 10%); background-color: red; &#125;&#125;/* iphone6 7 8 plus */@media screen and (max-width: 414px) &#123; aside &#123; float: none; width: 100%; height: 5%; background-color: yellow; &#125; main &#123; height: calc(100vh - 5%); background-color: red; &#125;&#125;/* iphoneX */@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 3) &#123; aside &#123; float: none; width: 100%; height: 10%; background-color: blue; &#125; main &#123; height: calc(100vh - 10%); background-color: red; &#125;&#125;/* iphone6 7 8 */@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 2) &#123; aside &#123; float: none; width: 100%; height: 3%; background-color: black; &#125; main &#123; height: calc(100vh - 3%); background-color: red; &#125;&#125;/* iphone5 */@media screen and (max-width: 320px) &#123; aside &#123; float: none; width: 100%; height: 7%; background-color: green; &#125; main &#123; height: calc(100vh - 7%); background-color: red; &#125;&#125; 三、移动端，pc端，pad端多端口适配1.媒体查询CSS3媒体查询可以让我们针对不同的媒体类型定义不同的样式，当重置浏览器窗口大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。 如何选择屏幕大小分割点如何确定媒体查询的分割点也是一个开发中会遇到的问题。 如果我们选择600px,900px,1200px,1800px作为分割点，可以适配到常见的14个机型。 当然这只是其中的一种分割方案，我们还可以这样划分：480px,800px,1400px,1400px。 上边两种分割方案不一定满足项目中的实际需求，我们可以先用跨度大的分割点进行分割，如果出现不适配的情况可以再根据实际情况增加新的分割点。 移动优先 or PC优先不管是移动优先还是PC优先，都是依据当随着屏幕宽度增大或减小的时候，后面的样式会覆盖前面的样式。因此，移动端优先首先使用的是min-width，PC端优先使用的max-width。 移动优先12345678910111213141516171819202122232425262728293031323334353637383940/* iphone6 7 8 */body &#123; background-color: yellow;&#125;/* iphone 5 */@media screen and (max-width: 320px) &#123; body &#123; background-color: red; &#125;&#125;/* iphoneX */@media screen and (min-width: 375px) and (-webkit-device-pixel-ratio: 3) &#123; body &#123; background-color: #0FF000; &#125;&#125;/* iphone6 7 8 plus */@media screen and (min-width: 414px) &#123; body &#123; background-color: blue; &#125;&#125;/* ipad */@media screen and (min-width: 768px) &#123; body &#123; background-color: green; &#125;&#125;/* ipad pro */@media screen and (min-width: 1024px) &#123; body &#123; background-color: #FF00FF; &#125;&#125;/* pc */@media screen and (min-width: 1100px) &#123; body &#123; background-color: black; &#125;&#125; pc优先12345678910111213141516171819202122232425262728293031323334353637383940/* pc width &gt; 1024px */ body &#123; background-color: yellow; &#125;/* ipad pro */@media screen and (max-width: 1024px) &#123; body &#123; background-color: #FF00FF; &#125;&#125;/* ipad */@media screen and (max-width: 768px) &#123; body &#123; background-color: green; &#125;&#125;/* iphone6 7 8 plus */@media screen and (max-width: 414px) &#123; body &#123; background-color: blue; &#125;&#125;/* iphoneX */@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 3) &#123; body &#123; background-color: #0FF000; &#125;&#125;/* iphone6 7 8 */@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 2) &#123; body &#123; background-color: #0FF000; &#125;&#125;/* iphone5 */@media screen and (max-width: 320px) &#123; body &#123; background-color: #0FF000; &#125;&#125; 四、其它布局方法1.flex布局谈到flex布局，我不知道有多少人跟我一样，在本能的想到justify-content:center与align-items:center两条属性之后，除此之外的其它属性居然显得格外陌生。 可以说包括我在内的大部分人，都是在被flex垂直水平居中方式所惊艳后才对其有所了解，以至于在日常开发中对于flex的使用，也确实更偏向于元素对齐方式的使用。 而flex布局则是一种新的布局方案，通过为修改父div的display属性，让父元素成为一个flex容器，从而可以自由的操作容器中子元素(项目)的排列方式。 例如我们让多个div横向排列，传统做法是使用浮动，但浮空后因为脱离文档流的缘故，父元素会失去高度，这又涉及了清除浮动等一系列的问题。 而flex布局相对简单很多，修改父元素display:flex，你会发现div自动就排列成了一行，而且没有浮动之后的副作用，从回流角度考虑，flex的性能更优于float；随着浏览器不断兼容以及旧版本的淘汰，flex布局注定会成为更为流行的布局方案。 优点容易上手，根据flex规则很容易达到某个布局效果。 缺点兼容性较差具体兼容性可参考 https://caniuse.com/#feat=flexbox 由上述网站兼容性可以知道pc端,尤其是ie浏览器对flex布局并不友好。而移动端ios7,android4.4以上对flex布局几乎没有太大影响了，在手机迭代更新如此快的今天，flex布局在移动端是一个不错的选择。 2.网格布局，栅格布局 Grid网格布局，兼容性较差 Columns栅格系统，往往需要依赖某个UI库，如Bootstrap 总结响应式布局的实现可以通过媒体查询+px,媒体查询+百分比，媒体查询+rem+js,vm/vh,vm/vh +rem这几种方式来实现。但每一种方式都是有缺点的，媒体查询需要选取主流设备宽度尺寸作为断点针对性写额外的样式进行适配，但这样做会比较麻烦，只能在选取的几个主流设备尺寸下呈现完美适配，另外用户体验也不友好，布局在响应断点范围内的分辨率下维持不变，而在响应断点切换的瞬间，布局带来断层式的切换变化，如同卡带的唱机般“咔咔咔”地一下又一下。通过百分比来适配首先是计算麻烦，第二各个属性中如果使用百分比，其相对的元素的属性并不是唯一的，这样就造成我们使用百分比单位容易使布局问题变得复杂。通过采用rem单位的动态计算的弹性布局，则是需要在头部内嵌一段脚本来进行监听分辨率的变化来动态改变根元素字体大小，使得CSS与JS 耦合了在一起。通过利用纯css视口单位实现适配的页面，是既能解决响应式断层问题，又能解决脚本依赖的问题的，但是兼容性还没有完全能结构接受。","categories":[{"name":"样式结构和布局","slug":"样式结构和布局","permalink":"http://yoursite.com/categories/%E6%A0%B7%E5%BC%8F%E7%BB%93%E6%9E%84%E5%92%8C%E5%B8%83%E5%B1%80/"}],"tags":[{"name":"样式结构和布局","slug":"样式结构和布局","permalink":"http://yoursite.com/tags/%E6%A0%B7%E5%BC%8F%E7%BB%93%E6%9E%84%E5%92%8C%E5%B8%83%E5%B1%80/"}]},{"title":"算法总结（js）","slug":"text","date":"2020-01-06T08:51:14.000Z","updated":"2020-07-15T14:51:42.831Z","comments":true,"path":"2020/01/06/text/","link":"","permalink":"http://yoursite.com/2020/01/06/text/","excerpt":"","text":"冒泡排序手写代码123456789101112131415161718let arr = [3, 4, 1, 2];let max = arr.length - 1;for(let i = 0; i &lt; max; i++)&#123; // 声明一个变量，作为标志位 // 如果某次循环完后，没有任何两数进行交换，就将标志位设置为 true，表示排序完成 let flag = true; for(let j = 0; j &lt; max - i; j++)&#123; if(arr[j] &gt; arr[j + 1])&#123; // 利用ES6数组的解构赋值交换数据 [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; flag = false; &#125; &#125; if(flag)&#123; break; &#125;&#125;console.log(arr); 选择排序手写代码123456789101112131415let arr = [3, 4, 1, 2];let len = arr.length;// 这里之所以是len-1，是因为到最后两个元素，交换位置，整个数组就已经排好序了。for(let i = 0; i &lt; len - 1; i++)&#123; let min = arr[i]; // j = i+1是把与自己比较的情况给省略掉 for(let j = i+1; j &lt; len; j++)&#123; if(arr[j] &lt; min)&#123; // 利用ES6数组的解构赋值交换数据 [arr[j], min] = [min, arr[j]]; &#125; &#125; arr[i] = min;&#125;console.log(arr);","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]}],"categories":[{"name":"其它","slug":"其它","permalink":"http://yoursite.com/categories/%E5%85%B6%E5%AE%83/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"样式结构和布局","slug":"样式结构和布局","permalink":"http://yoursite.com/categories/%E6%A0%B7%E5%BC%8F%E7%BB%93%E6%9E%84%E5%92%8C%E5%B8%83%E5%B1%80/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"其它","slug":"其它","permalink":"http://yoursite.com/tags/%E5%85%B6%E5%AE%83/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"样式结构和布局","slug":"样式结构和布局","permalink":"http://yoursite.com/tags/%E6%A0%B7%E5%BC%8F%E7%BB%93%E6%9E%84%E5%92%8C%E5%B8%83%E5%B1%80/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]}